```{r}
library(httr)
library(jsonlite) 
library(sp)
library(spatstat)
library(sf)
library(automap)
library(tmaptools)
library(ggplot2)

```


```{r}
#tworzymy listę plików z danymi, aby móc je później wspólnie przetwarzać
files <- list.files(pattern = "^dane_.*\\.RData$")
files
```

```{r}
#ładujemy teraz wszystkie pliki z listy files do środowiska i wpakowujemy do listy lista_danych
lista_danych <- lapply(files, function(f) {
  e <- new.env() #jakby wszystko pakować do Global Environment to by się dane nadpisywały
  load(f, envir = e)
  e$list_inst2
})
```

```{r}
#teraz tak działa odwoływanie się
lista_danych[[2]][[6]]$current$values


```



```{r}
#funckja tworząca wektor z wartościami PM2.5
get_pm25 <- function(plik) {
  n_id <- length(plik)
  pm25 <- rep(NA,n_id)   # przygotowujemy wektor wyników
  
  for (i in seq(1,n_id)) {
    inst <- plik[[i]]
    
    logic <- inst$current$values$name == "PM25"
    
    if (sum(logic) == 1) {
      pm25[i] <- inst$current$values[logic,2]
    }
    
  }
  
  
  return(pm25)
}
```

```{r}
lista_pm25 <- lapply(lista_danych, get_pm25)


#sprawdzenie
#lista_pm25[[1]][64]

cz <- replicate(64, 0, simplify = FALSE)
for (i in 1:10) {
  print(i)
  for (j in 1:64) {
    if (!is.na(lista_pm25[[i]][j])) {
      cz[[j]] <- cz[[j]] + lista_pm25[[i]][j]
    }
  }
}
```

```{r}
#do pobrania samych stacji jakie są
#wzielam srodek Krakowa jako wspolrzedne (50.04666667N, 20.00486111E) i odleglosc 25km, zeby Nowa Hute tez na pewno lapało

r <- GET("https://airapi.airly.eu/v2/installations/nearest?lat=50.04666667&lng=20.00486111&maxDistanceKM=25&maxResults=-1", 
         add_headers(apikey = "TAScUh3ZHNuoMD3VgAr1NhuDyT9KbwW3", Accept = "application/json")
)
```

```{r}
jsonRespText<-content(r,as="text")
lista_czujnikow<-fromJSON(jsonRespText)

#tworzymy ramkę df - z danymi o lokalizacji, wysokości i id czjników
longitude<-lista_czujnikow$location$longitude
latitude<-lista_czujnikow$location$latitude
df_czujniki<-data.frame(longitude,latitude)
df_czujniki$elevation<-lista_czujnikow$elev #wysokość nie bedzie potrzebna, ale niech będzie
df_czujniki$id<-lista_czujnikow$id
head(df_czujniki)
#View(df_czujniki)
```


```{r}
data_spat<-data.frame(lon=df_czujniki$longitude,lat=df_czujniki$latitude,elev=df_czujniki$elev,id=df_czujniki$id)
coordinates(data_spat) <- ~lon+lat #określamy, które elementy to koordynaty (potrzebne do ppp)
proj4string(data_spat) <- CRS("+proj=longlat +datum=WGS84") #określamy, jaki mamy układ
head(data_spat) # mamy już obiekt w układzie sferycznym, który można automatycznie konwertować

#konwersja do UTM (bo tworzymy ppp, a to jego układ)
data_UTM <- spTransform(data_spat, CRS("+proj=utm +zone=34 +datum=WGS84"))

#aby utworzyć obiekt ppp, ale tylko z czujnikami w Krakowie, musimy mieć kontur Krakowa, którym przytniemy data_UTM 
#tworzymy więc odpowiedni obiekt w ukłądzie UTM (zmienna krakowUTM)
dzielnice<-st_read("dzielnice_Krakowa.shp") #układ odniesienia(CRS) to ETRS89 (Poland CS92)
# konwertujemy do WGS84
dzielniceWGS84<-st_transform(dzielnice,crs = 4326) # "4326" to kod dla WGS84
# zostawiamy tylko kontur miasta 
krakowWGS84<-st_union(dzielniceWGS84)
#konwertujemy go na UTM
krakowUTM<-st_transform(krakowWGS84,CRS("+proj=utm +zone=34 +datum=WGS84"))

#teraz możemy już utworzyć obiekt ppp z danymi ("marks") w punktach (uwaga: dane to id), przycięcie oknem krakowUTM
#jeszcze zmienna pomocnicza z koordynatami (bo spTransform wprowadza swoje nazwy kolumn z koordynatami)
XY<-coordinates(data_UTM)
#i obiekt ppp 2D:
czujniki_ppp_id<-ppp(x=XY[,1],y=XY[,2],marks=data.frame(elev=data_UTM$elev,id=data_UTM$id),window=as.owin(krakowUTM))
czujniki_ppp_id$marks$id #mamy od razu tylko te id które są w Krakowie
```
```{r}
czujniki_spdf <- as.data.frame(czujniki_ppp_id)
coordinates(czujniki_spdf) <- ~x+y # koordynaty
proj4string(czujniki_spdf) <- CRS("+proj=utm +zone=34 +datum=WGS84") # układ odniesienia
# dodajemy kolumny z pm

pm25_names <- c(
  "pm25_04_8",  "pm25_04_16",  "pm25_04_21",
  "pm25_09_8",  "pm25_09_16",  "pm25_09_21",
  "pm25_12_8",  "pm25_12_16",  "pm25_12_21", "pm25_14_20"
)

czujniki_spdf@data[pm25_names] <- lista_pm25
#teraz mamy 9 dodatkowych kolumn z danymi
(czujniki_spdf)
#View(czujniki_spdf@data)
plot(czujniki_spdf)
```



```{r}

miss <-lapply(pm25_names, function(colname) {
  is.na(czujniki_spdf@data[[colname]])
    
})


for (row in seq_len(nrow(czujniki_spdf@data))){
  if(row == 2 | row == 63){
       for( i in seq(1,length(miss))){
#        miss[[i]][row] = TRUE
       }
    }
}


names(miss) <- paste0("miss_", pm25_names)


miss

for (colname in pm25_names){
  #miss_vec <- miss[[paste0("miss_", colname)]]
  #m<-sort(czujniki_spdf@data[!miss_vec,colname],decreasing = FALSE)[10]
  #w<-sort(czujniki_spdf@data[!miss_vec,colname],decreasing = TRUE)[3]
  for( r in  seq_len(nrow(czujniki_spdf@data))){
    
    if((czujniki_spdf@data[r,colname]<=m)| (czujniki_spdf@data[r,colname]>=w)|is.na(czujniki_spdf@data[r,colname])){
      #miss[[paste0("miss_", colname)]][r] <- TRUE
      #print(r)
      #print(miss[[colname]][r])
    }else{
      #miss[[paste0("miss_", colname)]][r] <- FALSE
    }
  }
}

sum(miss[[colname]])
```

```{r}
colname<-pm25_names[1]
miss_vec <- miss[[paste0("miss_", colname)]]
m<-sort(czujniki_spdf@data[!miss_vec,colname])[20]
m
for( r in  seq_len(nrow(czujniki_spdf@data))){
  if((czujniki_spdf@data[r,1]<m)|is.na(czujniki_spdf@data[r,colname])){
    miss[[colname]][r] <- TRUE
    print(r)
    print(miss[[colname]][r])
  }else{
    miss[[colname]][r] <- FALSE
  }
}
sum(miss[[1]])
```

```{r}
a<-as.data.frame(czujniki_spdf[!miss_vec,3:12])
a<-a[1:10]
working<-!(rowSums(a)<50 | is.na(rowSums(a)))
working
length(working)
miss_vec
```



```{r}

#i kriging na wypasie, jeszcze raz to co już było tylko "marks" jest zmienione na "current"
#zarys krakowa w odpowiednim formacie
bound<-st_as_sf(krakowUTM)
plot(bound)
##pobierzmy współrzędne punktów konturu w formie macierzy
coord<-as.data.frame(st_coordinates(krakowUTM))
#tworzymy siatkę - prostokąt okalajacy kontur Krakowa
##określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
##ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
##przeliczamy: ile oczek siatki przypada na długość i szerokość naszego prostokąta 
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę 
#wreszcie siatka
grid <- GridTopology(left_down, size,num_points)
# kowersja siatki do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34 +datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie

#przycinamy siatkę konturem funkcją crop_shape z pakietu tmaptools
#install.packages("tmaptools")

g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg))#konwersja z powrotem do st i następnie do SpatialPixels
plot(spgrid)
```
```{r}
colname
colname <- "pm25_04_8"
miss_vec <- miss[[paste0("miss_", colname)]]
miss_vec
czujniki_spdf[!miss_vec,]
a<-as.data.frame( czujniki_spdf[!miss_vec,3:12] )
a<-a[1:10]

is.na(any(a))
working<-(rowSums(a)<50  )
working<-(working==FALSE | is.na(working))
working  
czujniki_spdf[!miss_vec,][working,]


miss_vec<-miss[[2]]
czujniki_spdf[!miss_vec,colname]

```

```{r}

for (colname in pm25_names) {
  miss_vec <- miss[[paste0("miss_", colname)]]
  print(miss_vec)
  PM25_gauss <- autoKrige(as.formula(paste(colname, "~ 1")), input_data = czujniki_spdf[!miss_vec,colname], new_data=spgrid,  model="Sph")
  
  
  print(nrow(czujniki_spdf[!miss_vec,colname]))
  print(plot(PM25_gauss$krige_output[1],main=colname))
  print(points(czujniki_ppp_id[!miss_vec,],pch="*",col="White"))
  print(plot(PM25_gauss))
}

```


```{r}
paleniska<-st_read("Potencjalnie_czynne_paleniska_w_2025.shp")


paleniska92<-st_transform(paleniska,crs = 2180)
centroids <- st_centroid(paleniska92)
paleniska_df <- cbind(st_coordinates(centroids),st_drop_geometry(centroids))

coordinates(paleniska_df) <- ~X+Y
proj4string(paleniska_df) <- CRS("+init=epsg:2180")

paleniska_UTM <- spTransform(
  paleniska_df,
  CRS("+proj=utm +zone=34 +datum=WGS84 +units=m +no_defs")
)

XY2 <- coordinates(paleniska_UTM)

paleniska_ppp <- ppp(
  x = XY2[,1],
  y = XY2[,2],
  window=as.owin(krakowUTM)
)


```
```{r}
library(dplyr)

paleniska_sf  <- st_as_sf(paleniska_UTM)
czujniki_sf <- st_as_sf(czujniki_spdf)

dist_mat <- st_distance(czujniki_sf, paleniska_sf)
dist_mat <- as.numeric(dist_mat) 
dim(dist_mat) <- c(nrow(czujniki_sf), nrow(paleniska_sf)) 
bandwidth <- 1000  # max buffer w  metrach 

weights <- exp(-(dist_mat^2) / (2 * bandwidth^2))

czujniki_sf$paleniska <- rowSums(weights)


corr_df <- data.frame(
  matrix(ncol = 4, nrow = 0)  # 3 columns, 0 rows
)

colnames(corr_df) <- c("PM25","paleniska","pora")

pm25_rano <- c(
  "pm25_04_8",  
  "pm25_09_8",  
  "pm25_12_8" 
)

for (colname in pm25_rano) {
  miss_vec <- miss[[paste0("miss_", colname)]]
  PM25 <- czujniki_spdf[!miss_vec,colname]
  length(PM25)
  czujniki_sf$paleniska
  
  corr_df <- rbind(corr_df, data.frame(PM25 = PM25[[1]],pora = "rano", paleniska = czujniki_sf$paleniska[!miss_vec]))
}


pm25_popoludniu <- c(
  "pm25_04_16",  
  "pm25_09_16",  
  "pm25_12_16" 
)

for (colname in pm25_popoludniu) {
  miss_vec <- miss[[paste0("miss_", colname)]]
  PM25 <- czujniki_spdf[!miss_vec,colname]
  
  czujniki_sf$paleniska[!miss_vec]
  
  corr_df <- rbind(corr_df, data.frame(PM25 = PM25[[1]],pora = "ppl", paleniska = czujniki_sf$paleniska[!miss_vec]))
}


pm25_wieczor <- c(
  "pm25_04_21",  
  "pm25_09_21",  
  "pm25_12_21"
)

for (colname in pm25_wieczor) {
  miss_vec <- miss[[paste0("miss_", colname)]]
  PM25 <- czujniki_spdf[!miss_vec,colname]
  
  czujniki_sf$paleniska[!miss_vec]
  
  corr_df <- rbind(corr_df, data.frame(PM25 = PM25[[1]],pora = "wieczor", paleniska = czujniki_sf$paleniska[!miss_vec]))
}





#for (k in 1:10){
#  for (i in 1:64) {
#    PM10 <- lista_danych[[k]][[i]]$current$values$value[list_inst2[[i]]$current$values$name == "PM10"]
#    PM25 <- lista_danych[[k]][[i]]$current$values$value[list_inst2[[i]]$current$values$name == "PM25"]
#    
#    if (is.null(PM10) || length(PM10) == 0) PM10=-1
#    if (is.null(PM25) || length(PM25) == 0) PM25=-1
#    corr_df <- rbind(corr_df, data.frame(id = i, PM10=PM10, PM25=PM25, emitery=czujniki_sf$paleniska[i]))
# }
#}

```


```{r}
library(ggplot2)
ggplot()+
  geom_sf(data = krakowUTM, fill = "lightblue")+
  geom_sf(data = st_buffer(paleniska_sf, dist = bandwidth), fill="lightgreen",color=NA)+
  geom_sf(data = czujniki_sf, color = "black")+
  geom_sf(data = paleniska_sf, color = "red")+
  theme_bw()

```

```{r}
corr_PM25 <- corr_df[,c("PM25","paleniska")]
filt_PM25 <- subset(corr_PM25)
filt_PM25

cor(x=filt_PM25$paleniska,y=filt_PM25$PM25)
cor.test(filt_PM25$paleniska, filt_PM25$PM25, method = "pearson")
plot(x=filt_PM25$paleniska,y=filt_PM25$PM25)

```
```{r}
corr_PM25 <- corr_df[,c("PM25","paleniska","pora")]
filt_PM25 <- subset(corr_PM25, pora=="rano")
filt_PM25

cor(x=filt_PM25$paleniska,y=filt_PM25$PM25)
cor.test(filt_PM25$paleniska, filt_PM25$PM25, method = "pearson")
plot(x=filt_PM25$paleniska,y=filt_PM25$PM25)

```
```{r}
corr_PM25 <- corr_df[,c("PM25","paleniska","pora")]
filt_PM25 <- subset(corr_PM25, pora=="ppl")
filt_PM25

cor(x=filt_PM25$paleniska,y=filt_PM25$PM25)
cor.test(filt_PM25$paleniska, filt_PM25$PM25, method = "pearson")
plot(x=filt_PM25$paleniska,y=filt_PM25$PM25)

```

```{r}
corr_PM25 <- corr_df[,c("PM25","paleniska","pora")]
filt_PM25 <- subset(corr_PM25, pora=="wieczor")
filt_PM25

cor(x=filt_PM25$paleniska,y=filt_PM25$PM25)
cor.test(filt_PM25$paleniska, filt_PM25$PM25, method = "pearson")
plot(x=filt_PM25$paleniska,y=filt_PM25$PM25)

```




```{r}
# dane o wietrze

wiatr_4 <- data.frame(
  time = pogoda_2026.01.04$Time,
  direction = pogoda_2026.01.04$Wind,
  speed_kmph = as.numeric(gsub(" mph", "", pogoda_2026.01.04$Wind.Speed)) * 1.61,   # zamiana mph na kmph
  stringsAsFactors = FALSE
)

wiatr_9 <- data.frame(
  time = pogoda_2026.01.09$Time,
  direction = pogoda_2026.01.09$Wind,
  speed_kmph = as.numeric(gsub(" mph", "", pogoda_2026.01.09$Wind.Speed)) * 1.61,   
  stringsAsFactors = FALSE
)

wiatr_12 <- data.frame(
  time = pogoda_2026.01.12$Time,
  direction = pogoda_2026.01.12$Wind,
  speed_kmph = as.numeric(gsub(" mph", "", pogoda_2026.01.12$Wind.Speed)) * 1.61,   
  stringsAsFactors = FALSE
)

# zmiana na format 24-godzinny, zeby było jak po polskiemu
to_24h <- function(x) format(strptime(x, format = "%I:%M %p"), "%H:%M")

wiatr_4$time  <- to_24h(wiatr_4$time)
wiatr_9$time  <- to_24h(wiatr_9$time)
wiatr_12$time <- to_24h(wiatr_12$time)

head(wiatr_4)
head(wiatr_9)
head(wiatr_12)
```


```{r}

# wykresy prędkości i kierunków wiatru

library(ggplot2)

dir_deg <- c(
  N=0, NNE=22.5, NE=45, ENE=67.5,
  E=90, ESE=112.5, SE=135, SSE=157.5,
  S=180, SSW=202.5, SW=225, WSW=247.5,
  W=270, WNW=292.5, NW=315, NNW=337.5
)

plot_wind_arrows <- function(df, day_label) {

  df$time_posix <- as.POSIXct(paste("2026-01-01", trimws(df$time)))  # ładna oś czasu

  deg <- dir_deg[df$direction]
  rad <- (270 - deg) * pi/180
  Lx_sec <- 10 * 60
  Ly     <- 0.5e
  df$xend <- df$time_posix + cos(rad) * Lx_sec
  df$yend <- df$speed_kmph + sin(rad) * Ly

  ggplot(df, aes(x = time_posix, y = speed_kmph)) +
    geom_line() +
    geom_segment(
      data = df[!is.na(deg) & !is.na(df$time_posix), ],
      aes(xend = xend, yend = yend),
      arrow = arrow(length = unit(0.25, "cm")),
      color = "blue",
      linewidth = 1.2
    ) +
    scale_x_datetime(date_labels = "%H:%M") +
    labs(title = day_label, x = "Godzina", y = "Prędkość wiatru [km/h]") +
    coord_cartesian(clip = "off") +
    theme_bw()
}

print(plot_wind_arrows(wiatr_4,  "2026-01-04"))
print(plot_wind_arrows(wiatr_9,  "2026-01-09"))
print(plot_wind_arrows(wiatr_12, "2026-01-12"))


```


